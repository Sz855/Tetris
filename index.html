<!DOCTYPE html>
<html>
<head>
    <title>Procedural Tanks</title>
    <style>
        canvas {
            border: 2px solid #333;
            background: #000;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #444;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="416" height="416"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 32;
        const MAP_SIZE = 13;
        
        let player = {
            x: 6 * TILE_SIZE,
            y: 12 * TILE_SIZE,
            direction: 0,
            speed: 2
        };
        
        let bullets = [];
        let enemies = [];
        let map = [];
        
        // Типы тайлов
        const TILE_TYPES = {
            EMPTY: 0,
            BRICK: 1,
            STEEL: 2,
            WATER: 3
        };
        
        // Генерация карты
        function generateMap() {
            map = [];
            // Заполнение случайными блоками
            for(let y = 0; y < MAP_SIZE; y++) {
                map[y] = [];
                for(let x = 0; x < MAP_SIZE; x++) {
                    if(Math.random() < 0.3 && x > 2 && x < MAP_SIZE-3 && y > 2) {
                        map[y][x] = Math.random() < 0.7 ? TILE_TYPES.BRICK : TILE_TYPES.STEEL;
                    } else {
                        map[y][x] = TILE_TYPES.EMPTY;
                    }
                }
            }
            
            // Добавление воды
            for(let i = 0; i < 3; i++) {
                const waterX = Math.floor(Math.random() * (MAP_SIZE-3));
                const waterY = Math.floor(Math.random() * (MAP_SIZE-3));
                for(let y = waterY; y < waterY+2; y++) {
                    for(let x = waterX; x < waterX+3; x++) {
                        map[y][x] = TILE_TYPES.WATER;
                    }
                }
            }
            
            // Гарантированные проходы
            for(let y = 0; y < MAP_SIZE; y++) {
                map[y][5] = TILE_TYPES.EMPTY;
                map[y][6] = TILE_TYPES.EMPTY;
                map[y][7] = TILE_TYPES.EMPTY;
            }
        }
        
        // Отрисовка карты
        function drawMap() {
            for(let y = 0; y < MAP_SIZE; y++) {
                for(let x = 0; x < MAP_SIZE; x++) {
                    switch(map[y][x]) {
                        case TILE_TYPES.BRICK:
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            break;
                        case TILE_TYPES.STEEL:
                            ctx.fillStyle = '#808080';
                            ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            break;
                        case TILE_TYPES.WATER:
                            ctx.fillStyle = '#0000FF';
                            ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            break;
                    }
                }
            }
        }
        
        // Отрисовка танка
        function drawTank(tank, color) {
            ctx.save();
            ctx.translate(tank.x + TILE_SIZE/2, tank.y + TILE_SIZE/2);
            ctx.rotate(tank.direction * Math.PI/2);
            ctx.fillStyle = color;
            ctx.fillRect(-TILE_SIZE/2, -TILE_SIZE/2, TILE_SIZE, TILE_SIZE);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(TILE_SIZE/4, -TILE_SIZE/4, TILE_SIZE/2, TILE_SIZE/2);
            ctx.restore();
        }
        
        // Обработка столкновений
        function checkCollision(x, y) {
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);
            
            if(tileX < 0 || tileX >= MAP_SIZE || tileY < 0 || tileY >= MAP_SIZE) {
                return true;
            }
            
            return map[tileY][tileX] === TILE_TYPES.BRICK || 
                   map[tileY][tileX] === TILE_TYPES.STEEL;
        }
        
        // Обновление игрока
        function updatePlayer() {
            let newX = player.x;
            let newY = player.y;
            
            if(keys.ArrowUp) {
                player.direction = 0;
                newY -= player.speed;
            }
            if(keys.ArrowDown) {
                player.direction = 2;
                newY += player.speed;
            }
            if(keys.ArrowLeft) {
                player.direction = 3;
                newX -= player.speed;
            }
            if(keys.ArrowRight) {
                player.direction = 1;
                newX += player.speed;
            }
            
            if(!checkCollision(newX, newY) &&
               !checkCollision(newX + TILE_SIZE-1, newY) &&
               !checkCollision(newX, newY + TILE_SIZE-1) &&
               !checkCollision(newX + TILE_SIZE-1, newY + TILE_SIZE-1)) {
                player.x = newX;
                player.y = newY;
            }
        }
        
        // Обработка стрельбы
        function fireBullet() {
            bullets.push({
                x: player.x + TILE_SIZE/2,
                y: player.y + TILE_SIZE/2,
                direction: player.direction,
                speed: 5
            });
        }
        
        // Обновление пуль
        function updateBullets() {
            bullets.forEach((bullet, index) => {
                switch(bullet.direction) {
                    case 0: bullet.y -= bullet.speed; break;
                    case 1: bullet.x += bullet.speed; break;
                    case 2: bullet.y += bullet.speed; break;
                    case 3: bullet.x -= bullet.speed; break;
                }
                
                // Проверка столкновений
                if(checkCollision(bullet.x, bullet.y)) {
                    const tileX = Math.floor(bullet.x / TILE_SIZE);
                    const tileY = Math.floor(bullet.y / TILE_SIZE);
                    if(map[tileY][tileX] === TILE_TYPES.BRICK) {
                        map[tileY][tileX] = TILE_TYPES.EMPTY;
                    }
                    bullets.splice(index, 1);
                }
            });
        }
        
        // Отрисовка пуль
        function drawBullets() {
            ctx.fillStyle = '#FFFF00';
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI*2);
                ctx.fill();
            });
        }
        
        // Обработка ввода
        let keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if(e.code === 'Space') fireBullet();
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });
        
        // Игровой цикл
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawMap();
            updatePlayer();
            updateBullets();
            
            drawTank(player, '#00FF00');
            drawBullets();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Инициализация игры
        generateMap();
        gameLoop();
    </script>
</body>
</html>
