<!DOCTYPE html>
<html>
<head>
    <title>Procedural Tanks</title>
    <style>
        canvas {
            border: 2px solid #333;
            background: #000;
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background: #444;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="416" height="416"></canvas>
    
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const TILE_SIZE = 32;
        const MAP_SIZE = 13;
        
        let player = {
            x: 6 * TILE_SIZE,
            y: 12 * TILE_SIZE,
            direction: 0,
            speed: 2
        };
        
        let bullets = [];
        let enemies = [];
        let map = [];
        
        // Типы тайлов
        const TILE_TYPES = {
            EMPTY: 0,
            BRICK: 1,
            STEEL: 2,
            WATER: 3
        };
        
        // Генерация карты
        function generateMap() {
            map = [];
            // Заполнение случайными блоками
            for(let y = 0; y < MAP_SIZE; y++) {
                map[y] = [];
                for(let x = 0; x < MAP_SIZE; x++) {
                    if(Math.random() < 0.3 && x > 2 && x < MAP_SIZE-3 && y > 2) {
                        map[y][x] = Math.random() < 0.7 ? TILE_TYPES.BRICK : TILE_TYPES.STEEL;
                    } else {
                        map[y][x] = TILE_TYPES.EMPTY;
                    }
                }
            }
            
            // Добавление воды
            for(let i = 0; i < 3; i++) {
                const waterX = Math.floor(Math.random() * (MAP_SIZE-3));
                const waterY = Math.floor(Math.random() * (MAP_SIZE-3));
                for(let y = waterY; y < waterY+2; y++) {
                    for(let x = waterX; x < waterX+3; x++) {
                        map[y][x] = TILE_TYPES.WATER;
                    }
                }
            }
            
            // Гарантированные проходы
            for(let y = 0; y < MAP_SIZE; y++) {
                map[y][5] = TILE_TYPES.EMPTY;
                map[y][6] = TILE_TYPES.EMPTY;
                map[y][7] = TILE_TYPES.EMPTY;
            }
        }
        
        // Отрисовка карты
        function drawMap() {
            for(let y = 0; y < MAP_SIZE; y++) {
                for(let x = 0; x < MAP_SIZE; x++) {
                    switch(map[y][x]) {
                        case TILE_TYPES.BRICK:
                            ctx.fillStyle = '#8B4513';
                            ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            break;
                        case TILE_TYPES.STEEL:
                            ctx.fillStyle = '#808080';
                            ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            break;
                        case TILE_TYPES.WATER:
                            ctx.fillStyle = '#0000FF';
                            ctx.fillRect(x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            break;
                    }
                }
            }
        }
        
        // Отрисовка танка
        function drawTank(tank, color) {
            ctx.save();
            ctx.translate(tank.x + TILE_SIZE/2, tank.y + TILE_SIZE/2);
            ctx.rotate(tank.direction * Math.PI/2);
            ctx.fillStyle = color;
            ctx.fillRect(-TILE_SIZE/2, -TILE_SIZE/2, TILE_SIZE, TILE_SIZE);
            ctx.fillStyle = '#FF0000';
            ctx.fillRect(TILE_SIZE/4, -TILE_SIZE/4, TILE_SIZE/2, TILE_SIZE/2);
            ctx.restore();
        }
        
        // Обработка столкновений
        function checkCollision(x, y) {
            const tileX = Math.floor(x / TILE_SIZE);
            const tileY = Math.floor(y / TILE_SIZE);
            
            if(tileX < 0 || tileX >= MAP_SIZE || tileY < 0 || tileY >= MAP_SIZE) {
                return true;
            }
            
            return map[tileY][tileX] === TILE_TYPES.BRICK || 
                   map[tileY][tileX] === TILE_TYPES.STEEL;
        }
        
        // Обновление игрока
        function updatePlayer() {
            let newX = player.x;
            let newY = player.y;
            
            if(keys.ArrowUp) {
                player.direction = 0;
                newY -= player.speed;
            }
            if(keys.ArrowDown) {
                player.direction = 2;
                newY += player.speed;
            }
            if(keys.ArrowLeft) {
                player.direction = 3;
                newX -= player.speed;
            }
            if(keys.ArrowRight) {
                player.direction = 1;
                newX += player.speed;
            }
            
            if(!checkCollision(newX, newY) &&
               !checkCollision(newX + TILE_SIZE-1, newY) &&
               !checkCollision(newX, newY + TILE_SIZE-1) &&
               !checkCollision(newX + TILE_SIZE-1, newY + TILE_SIZE-1)) {
                player.x = newX;
                player.y = newY;
            }
        }
        
        // Обработка стрельбы
        function fireBullet() {
            bullets.push({
                x: player.x + TILE_SIZE/2,
                y: player.y + TILE_SIZE/2,
                direction: player.direction,
                speed: 5
            });
        }
        
        // Обновление пуль
        function updateBullets() {
            bullets.forEach((bullet, index) => {
                switch(bullet.direction) {
                    case 0: bullet.y -= bullet.speed; break;
                    case 1: bullet.x += bullet.speed; break;
                    case 2: bullet.y += bullet.speed; break;
                    case 3: bullet.x -= bullet.speed; break;
                }
                
                // Проверка столкновений
                if(checkCollision(bullet.x, bullet.y)) {
                    const tileX = Math.floor(bullet.x / TILE_SIZE);
                    const tileY = Math.floor(bullet.y / TILE_SIZE);
                    if(map[tileY][tileX] === TILE_TYPES.BRICK) {
                        map[tileY][tileX] = TILE_TYPES.EMPTY;
                    }
                    bullets.splice(index, 1);
                }
            });
        }
        
        // Отрисовка пуль
        function drawBullets() {
            ctx.fillStyle = '#FFFF00';
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI*2);
                ctx.fill();
            });
        }
        
        // Обработка ввода
        let keys = {};
        window.addEventListener('keydown', e => {
            keys[e.key] = true;
            if(e.code === 'Space') fireBullet();
        });
        window.addEventListener('keyup', e => {
            keys[e.key] = false;
        });
        
        // Игровой цикл
        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawMap();
            updatePlayer();
            updateBullets();
            
            drawTank(player, '#00FF00');
            drawBullets();
            
            requestAnimationFrame(gameLoop);
        }
        
        // Инициализация игры
        generateMap();
        gameLoop();
    </script>
    let gameActive = true;

// Добавляем отображение здоровья игрока
function drawHUD() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('health').textContent = playerHealth;
}

// Функция завершения игры
function gameOver(victory) {
    gameActive = false;
    const gameOverDiv = document.getElementById('game-over');
    gameOverDiv.style.display = 'block';
    gameOverDiv.innerHTML = victory ? 
        '<h2>Победа!</h2><button onclick="location.reload()">Играть снова</button>' :
        '<h2>Game Over!</h2><button onclick="location.reload()">Попробовать снова</button>';
}

// Обновленная функция проверки столкновений пуль
function updateBullets() {
    bullets.forEach((bullet, index) => {
        // Обновление позиции
        switch(bullet.direction) {
            case 0: bullet.y -= bullet.speed; break;
            case 1: bullet.x += bullet.speed; break;
            case 2: bullet.y += bullet.speed; break;
            case 3: bullet.x -= bullet.speed; break;
        }

        // Проверка попадания в игрока
        if(bullet.type === 'enemy') {
            const distance = Math.sqrt(
                Math.pow(bullet.x - (player.x + TILE_SIZE/2), 2) +
                Math.pow(bullet.y - (player.y + TILE_SIZE/2), 2)
            );
            if(distance < TILE_SIZE/2) {
                playerHealth -= 20;
                bullets.splice(index, 1);
                if(playerHealth <= 0) gameOver(false);
                return;
            }
        }

        // Проверка столкновения с блоками
        if(checkCollision(bullet.x, bullet.y)) {
            const tileX = Math.floor(bullet.x / TILE_SIZE);
            const tileY = Math.floor(bullet.y / TILE_SIZE);
            if(map[tileY][tileX] === TILE_TYPES.BRICK) {
                map[tileY][tileX] = TILE_TYPES.EMPTY;
                score += 10;
            }
            bullets.splice(index, 1);
        }
    });
}

// Модифицированный игровой цикл
function gameLoop() {
    if(!gameActive) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    updatePlayer();
    enemies.forEach(enemy => enemy.update());
    updateBullets();
    updatePowerups();

    // Проверка условий завершения игры
    if(enemies.length === 0) {
        gameOver(true);
    }
    
    drawMap();
    drawTank(player, '#00FF00');
    enemies.forEach(enemy => drawTank(enemy, '#FF0000'));
    drawBullets();
    drawPowerups();
    drawHUD();

    requestAnimationFrame(gameLoop);
}

// Обновленный HTML (добавить в body):
<div id="hud">
    Score: <span id="score">0</span> | 
    Level: <span id="level">1</span> | 
    Health: <span id="health">100</span>
</div>
<div id="game-over" style="display: none; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; text-align: center;"></div>

// Инициализация игры
function initGame() {
    generateMap();
    spawnEnemies();
    gameActive = true;
    playerHealth = 100;
    score = 0;
    level = 1;
    gameLoop();
}

// Обновленная функция спавна врагов
function spawnEnemies() {
    enemies = [];
    for(let i = 0; i < 20 + level*2; i++) {
        enemies.push(new EnemyTank());
    }
}
</script>
</body>
</html>
